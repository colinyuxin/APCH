---
title: "APCH Introduction"
author: "Your Name"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{APCH Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 7,
  fig.height = 4
)
# Load the package; assume data simulation helpers (generate_data, etc.) are exported by the package
library(apch)
set.seed(123)
```

# Introduction

This vignette is a comprehensive, practical guide to the `apch` package. It documents the four main user-facing functions and provides examples using simulated correlated multi-feature data. 

The four main functions covered are:

- `apch()` — full pipeline: feature-level adaptive shrinkage, configuration-level EM, and level-by-level inference.
- `fit_all_featutre()` — feature-level adaptive shrinkage; inspect or reuse per-feature grids and mixture weights.
- `level_by_level_inference()` — level_by_level inference.
- `apch_posterior()` — computes posterior means, marginal variances, and (optionally) full covariance matrices per effect.

# Installation

If you haven't installed the package yet, install the development version and load it:

```{r install, eval=FALSE}
# devtools::install_github("yourusername/apch")
# library(apch)
```

# Simulating example data (`n = 5000, p = 3`)

We use the package-provided `generate_data()` to simulate observed estimates `B_hat`, true signals `B_true`, the latent activation matrix `gamma_true`, the feature correlation `R`, and the full configuration matrix `configs`. 

```{r simulate-data}
p <- 3
n <- 5000

# Example correlation matrix (moderate correlations)
rho <- matrix(c(1, 0.4, 0.2,
                0.4, 1, 0.3,
                0.2, 0.3, 1), nrow = p, byrow = TRUE)

# Per-feature scenario names must match those supported by the package's get_scenario_params()
distributions <- c("spiky", "near_normal", "std_normal1")

# Optionally supply a custom delta; otherwise the package default will be used
delta_true <- NULL

dat <- apch:::generate_data(
  n = n, p = p,
  delta = delta_true,
  distributions = distributions,
  lambda = 2.5,
  rho = rho
)

cat("Simulated X dimensions (B_hat):", dim(dat$B_hat)[1], "x", dim(dat$B_hat)[2], "\n")
```

# Quick overview of key objects

- `dat$B_hat` — observed effect estimates (n × p). Use as `X`.
- `dat$B_true` — true underlying signals (n × p) (for simulation diagnostics).
- `dat$gamma_true` — true binary activation matrix (n × p).
- `dat$configs` — configuration matrix (K × p) with all 2^p configurations.
- `dat$R` — p × p correlation matrix used for noise generation.

# workflow

1. (Optional) Run `fit_all_featutre()` to obtain or inspect per-feature grids and mixture weights.
2. Run `apch()` for the end-to-end analysis (fast `output = "light"` for exploration; `output = "full"` when you need full posterior).
3. Use `level_by_level_inference()` on `w_mat` and `configs` to extract calls if running the EM separately.
4. Use `apch_posterior()` to compute posterior means, variances and optionally full covariances for downstream analysis.

# `apch()`: full APCH

## Purpose

`apch()` combines feature-level adaptive shrinkage with a configuration-level block-diagonal EM and level-by-level inference to detect effects that are active across multiple features. It is the recommended entry-point for most analyses.

## Key arguments

- `X` : numeric matrix (n × p) of observed estimates.
- `S` : numeric matrix (same size) of standard errors.
- `R_cor` : p × p correlation matrix among features.
- `mixcompdist` : mixture slab family; typically `"normal"`.
- `lambda0_ash` : regularization for feature-layer fit (larger = more shrinkage).
- `workers` : integer, number of parallel R workers for feature fits (EM uses C++ threads).
- `output` : `"light"` (summary) or `"full"` (full).
- `distill` : controls grid distillation; `"auto"` recommended for large n.

## Example (light mode)

```{r run-apch, message=TRUE}
X <- dat$B_hat
S <- matrix(1, nrow = nrow(X), ncol = ncol(X))

apch_res <- apch(
  X = X,
  S = S,
  R_cor = dat$R,
  mixcompdist = "normal",
  lambda0_ash = 10,
  alpha = 0.05,
  output = "light",
  workers = 2,
  verbose = TRUE
)

# Top-level summary
cat("Available elements in apch_res:", paste(names(apch_res), collapse = ", "), "\n")
cat("Number of detected calls:", nrow(apch_res$infer_res$calls), "\n")
head(apch_res$infer_res$calls)
```

## Output interpretation

- `apch_res$ashr_res` : per-feature fit outputs. Inspect `signed_grids` and `pi_list`.
- `apch_res$em_res` : EM results and diagnostics; contains `w_mat` (n × K), and convergence info.
- `apch_res$infer_res` : level-by-level inference results; `calls` contains detected conjunctions.
- `apch_res$post_mean_called` : (light mode, Gaussian) posterior means for called effects.

# `fit_all_featutre()`: feature-level adaptive shrinkage

## Purpose

Fits adaptive shrinkage models to each feature independently. Useful for inspecting per-feature mixture grids and weights or when reusing feature-level outputs across EM runs.

## Key arguments

- `distill` : `TRUE`, `FALSE`, or `"auto"`. `"auto"` uses an internal heuristic based on `R_cor` and `cor_thresh`.
- grid controls : used internally for grid construction.
- `workers`, `plan` : parallelization controls for `future`.

## Example

```{r run-fit-features}
fit_feat <- fit_all_featutre(
  X = X,
  S = S,
  mixcompdist = "normal",
  lambda0 = 10,
  distill = "auto",
  R_cor = dat$R,
  cor_thresh = sqrt(.Machine$double.eps),
  workers = 2,
  plan = "multisession",
  output = "light",
  verbose = TRUE
)

# Inspect structure
str(fit_feat, max.level = 2)
cat("Features with grids:", paste(names(fit_feat$signed_grids), collapse = ", "), "\n")
# first few components of the first feature's grid and weights
print(head(fit_feat$signed_grids[[1]]))
print(head(fit_feat$pi_list[[1]]))
```


# `level_by_level_inference()`: calls from w_mat

## Purpose

Turns the posterior configuration weight matrix `w_mat` into calls across conjunction levels using FDR control with level_by_level inference.

## Inputs

- `w_mat` (n × K) : posterior weights per effect per configuration.
- `configs` (K × p) : configuration matrix with binary activation patterns.
- `alpha`, `null_th`, `ppa_min` : inference thresholds.

## Example

```{r run-level-infer}
configs <- dat$configs
w_mat <- apch_res$em_res$w_mat

lvl_res <- level_by_level_inference(
  w_mat = w_mat,
  configs = configs,
  alpha = 0.05,
  null_th = 0.9,
  ppa_min = 0.5,
  feature_names = paste0("F", 1:p)
)

cat("Calls returned:", nrow(lvl_res$calls), "\n")
head(lvl_res$calls)
```

## Output details

- `effect` : effect identifier (rownames of `w_mat` or index).
- `L` : conjunction level (asserts activity in at least `L` features).
- `lfdr` : local false discovery rate for the call.
- `subset` : features included in the called subset (text).
- `subset01` : binary mask string for the subset.

# `apch_posterior()`: posterior summaries

## Purpose

Compute posterior means, marginal variances and optional full covariances per effect under the Gaussian slab assumption.

## Key arguments

- `grid_list`, `pi_list` : per-feature signed grids and mixture weights (from `fit_all_featutre()`).
- `return_cov_full` : logical; set to `TRUE` to obtain full p × p covariance matrices for each effect.
- `w_thresh` : truncation threshold for small posterior weights to stabilize numerics.

## Example

```{r run-posterior}
grid_list <- apch_res$ashr_res$signed_grids
pi_list   <- apch_res$ashr_res$pi_list
w_mat <- apch_res$em_res$w_mat
configs <- dat$configs

post_res <- apch_posterior(
  X = X,
  S = S,
  R_cor = dat$R,
  w_mat = w_mat,
  cfg = configs,
  grid_list = grid_list,
  pi_list = pi_list,
  mixcompdist = "normal",
  return_cov_full = FALSE,
  w_thresh = 1e-12
)

cat("Posterior mean matrix dims:", dim(post_res$mean), "\n")
print(head(post_res$mean))
```


# Diagnostics, visualization, and interpretation


```{r diagnostics, fig.height=5}
library(ggplot2)

# 1. Configuration posterior mass (top configurations)
w_sum_per_cfg <- colSums(apch_res$em_res$w_mat)
cfg_mat <- apch:::generate_all_configs(p = 3)
cfg_labels <- apply(cfg_mat, 1, paste0, collapse = "")
top_ix <- order(w_sum_per_cfg, decreasing = TRUE)[1:min(20, length(w_sum_per_cfg))]
bar_df <- data.frame(cfg = factor(cfg_labels[top_ix], levels = cfg_labels[top_ix]),
          mass = w_sum_per_cfg[top_ix])
ggplot(bar_df, aes(x = cfg, y = mass)) +
  geom_col() +
  labs(title = "Top configuration posterior mass", x = "Configuration index", y = "Total posterior mass") +
  theme_minimal()

# 2. Local FDR distribution for calls
calls_df <- apch_res$infer_res$calls
if (nrow(calls_df) > 0) {
  ggplot(calls_df, aes(x = factor(L), y = lfdr)) +
    geom_jitter(width = 0.2, alpha = 0.6) +
    labs(title = "Local FDR by conjunction level", x = "Conjunction level (L)", y = "Local FDR") +
    theme_minimal()
}
```

## Interpreting plots

- Configuration mass plot shows which activation patterns collectively explain most posterior probability across effects.
- Local FDR plot helps assess reliability of calls at different conjunction levels.

# Performance and tuning recommendations

- Use `output = "light"` during exploration to reduce memory usage.
- Enable `distill = "auto"` for per-feature grid simplification when `n` is large.



