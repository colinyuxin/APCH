% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apch.R
\name{apch}
\alias{apch}
\alias{apch_workhorse}
\title{Adaptive Partial Conjunction Hypotheses (APCH)}
\usage{
apch(
  X,
  S,
  C = NULL,
  mixcompdist = "normal",
  alpha = 0.05,
  mode = c("meta", "xwas"),
  workers = 8,
  plan = NULL,
  verbose = TRUE
)

apch_workhorse(
  X,
  S,
  C = NULL,
  mode = c("meta", "xwas"),
  mixcompdist = "normal",
  lambda0_ash = 10,
  alpha = 0.05,
  null_th = 0.9,
  ppa_min = 0.5,
  distill = "auto",
  fine_s_min_mult = 0.5,
  fine_s_max_mult = 1,
  fine_mult_distill = 1.35,
  fine_mult_nodistill = sqrt(2),
  workers = 8,
  plan = NULL,
  verbose = TRUE,
  progress_chunk = 128,
  ashr_control = list(),
  solver_stageA = c("mixsqp", "em", "loglinear"),
  solver_stageB = c("loglinear", "mcmc", "mixsqp", "em"),
  stageA_ll_tol = 0.01,
  stageB_ll_tol = 0.01,
  force_one_block = FALSE,
  compute_posterior = TRUE
)
}
\arguments{
\item{X}{Numeric matrix of observed effect estimates with dimension
\eqn{n \times p} (rows = effects, columns = features). Required.}

\item{S}{Numeric matrix of standard errors with the same dimensions as \code{X}.}

\item{C}{Observation-noise structure. For \code{mode = "meta"}, a numeric
\eqn{p \times p} matrix shared across all effects (the global \eqn{C} in
the APCH model, typically a correlation matrix in meta-analysis). If
\code{NULL}, the identity matrix is used. For \code{mode = "xwas"},
\code{C} encodes per-effect noise covariance: either a list of length
\code{n} of \eqn{p \times p} matrices, or a \eqn{p \times p \times n}
array. Internally this is normalized to a list.}

\item{mixcompdist}{Character specifying the mixture component distribution used
by the adaptive shrinkage step. Typical values include \code{"normal"},
\code{"uniform"},
\code{"halfuniform"}, and \code{"halfnormal"}.
Default: \code{"normal"}.}

\item{alpha}{Numeric overall significance level used by the level-by-level
inference (e.g. FDR). Default: \code{0.05}.}

\item{mode}{Character string specifying the observation-noise model:
\itemize{
\item \code{"meta"}: a single global matrix \eqn{C} shared across all
effects (standard meta-analysis setting).
\item \code{"xwas"}: per-effect noise matrices \eqn{C_i}; \code{C} must
be supplied as a list of length \code{n} of \eqn{p \times p} matrices
or a \eqn{p \times p \times n} array. This mode is supported throughout
the feature, EM and posterior layers, assuming the corresponding C++
backends are available.
}
Additional labels are reserved for future extensions and are not yet
supported.}

\item{workers}{Integer number of parallel workers to use at the R/future
level. This will be capped at the number of features for the feature-level
step and generally capped at 8 for the configuration layer. Default: \code{8}.}

\item{plan}{Optional character controlling the \pkg{future} plan:
\code{"multisession"} or \code{"multicore"}. If \code{NULL}, the function
chooses a reasonable default (multisession on Windows/RStudio,
multicore on Unix-like systems). Default: \code{NULL}.}

\item{verbose}{Logical; when \code{TRUE}, print diagnostic and informational
messages. Default: \code{TRUE}.}

\item{lambda0_ash}{Numeric regularization parameter used by the ashr
feature-layer fit. Larger values encourage sparser solutions.
Default: \code{10}.}

\item{null_th}{Numeric posterior probability threshold to treat an effect as
null when computing calls (e.g. if posterior probability of null
\eqn{\ge} \code{null_th} then it is considered null). Default: \code{0.9}.}

\item{ppa_min}{Numeric minimum posterior probability of activation (PPA)
required to report a call. Default: \code{0.5}.}

\item{distill}{Logical, \code{"auto"}, integer vector, or character specifying
whether to perform grid distillation at the feature-level. For
\code{mode = "meta"}, \code{"auto"} uses a heuristic based on the global
\code{C} and an internal correlation threshold. For \code{mode = "xwas"},
all features are currently forced to be distilled.}

\item{fine_s_min_mult, fine_s_max_mult}{Numeric multipliers controlling the
lower and upper range of the fine ashr grid (passed to
\code{\link{fit_all_feature}}). Default: \code{0.5} and \code{1.0}.}

\item{fine_mult_distill, fine_mult_nodistill}{Numeric multipliers controlling
the grid refinement step size for features selected for distillation and
for non-distilled features, respectively. These are forwarded to
\code{\link{fit_all_feature}} and then used as \code{fine_mult} in
\code{distill_grid_path_from_xs()}. Default: \code{1.35} and \code{sqrt(2)}.}

\item{progress_chunk}{Integer chunk size for progress updates in the EM /
configuration computations. Default: \code{128}.}

\item{ashr_control}{Optional named list of additional arguments forwarded to
\code{\link{fit_all_feature}}. This can be used in meta-analysis mode to
tweak the ashr grid construction (e.g. \code{fine_s_min_mult},
\code{fine_s_max_mult}, \code{fine_max_len}, \code{min_grid_len},
\code{pair_frac}, \code{rel_thresh}, \code{mll_drop_total_tol},
\code{ks_increase_total_tol}, \code{mixsqp_control}), beyond what is
controlled by \code{lambda0_ash} and \code{mixcompdist}. Arguments in
\code{ashr_control} override the defaults set via the explicit parameters.}

\item{solver_stageA}{Character; solver for Stage A of the configuration
layer. Options are \code{"mixsqp"} (optimized default),
\code{"em"} (legacy EM+SQUAREM), or \code{"loglinear"} (softmax + L2
penalty on the \eqn{\eta}-pattern weights at the block level).}

\item{solver_stageB}{Character; solver for Stage B of the configuration
layer. Options are \code{"loglinear"} (default, Ising + ridge),
\code{"mcmc"}, \code{"mixsqp"}, or \code{"em"}.
Stage B is only used when \code{force_one_block = FALSE} in meta-analysis
mode; in xwas mode a single-block Stage-A-only variant is used.}

\item{stageA_ll_tol}{Numeric tolerance for the Stage-A \code{"loglinear"}
solver (softmax + L2 over \eqn{\eta}-patterns). Default \code{0.01}.
Ignored by other Stage-A solvers.}

\item{stageB_ll_tol}{Numeric tolerance for the Stage-B \code{"loglinear"}
solver (Ising + ridge). Default \code{0.01}. Ignored by non-loglinear
Stage-B solvers.}

\item{force_one_block}{Logical; when \code{TRUE} in meta-analysis mode the
configuration layer treats all features as a single block, all features
are distilled at the feature layer, and only Stage A is used to infer
configuration probabilities (Stage B is skipped). Ignored in
\code{mode = "xwas"}, where a single-block Stage-A-only solver is always
used.}

\item{compute_posterior}{Logical; when \code{FALSE}, skip the posterior
layer and return \code{posterior = NULL}. This avoids calling
\code{\link{apch_posterior}} and leaves \code{infer_res$calls$post_mean}
as an empty list, which is useful for fast timing / debugging. Default:
\code{TRUE}.}
}
\value{
The high-level \code{apch()} function returns a named list in a “light” form:
\describe{
\item{ashr_res}{Feature-layer adaptive shrinkage outputs in light form:
a list with elements \code{signed_grids} and \code{pi_list} only.
For full ashr fit objects, see \code{apch_workhorse()}.}
\item{config_res}{Configuration-layer outputs in light form:
currently the posterior configuration weights matrix \code{w_mat}.}
\item{infer_res}{Level-by-level inference outputs:
\code{calls} (data.frame of detected conjunctions), \code{est_fdr}
(estimated FDR), and auxiliary items.}
\item{post_mean_called}{Numeric matrix of posterior means for the called
effects (rows = called effects, columns = features) when
\code{mixcompdist = "normal"}. For non-Gaussian slabs the entries are
filled with \code{NA_real_}. If there are no calls, this is a
0 × p matrix.}
}

Hyperparameters \code{lambda0_ash = 10}, \code{null_th = 0.9},
\code{ppa_min = 0.5} are fixed in \code{apch()}; advanced users can change
them via \code{apch_workhorse()}.

A named list in “full” form:
\describe{
\item{ashr_res}{Feature-level ashr results (grids, mixture weights, and
optionally full fit objects, depending on \code{fit_all_feature()}).}
\item{config_res}{Configuration-layer results including \code{w_mat}
(posterior configuration weights), convergence info, and diagnostics.}
\item{infer_res}{Level-by-level inference outputs:
\code{calls} (data.frame of detected conjunctions), \code{est_fdr}
(estimated FDR), and auxiliary items. Each call also carries a
\code{post_mean} entry (list of posterior means per feature) when
Gaussian and \code{compute_posterior = TRUE}. When
\code{compute_posterior = FALSE}, this field is an empty list.}
\item{posterior}{Full posterior summaries:
\code{mean}, \code{var_diag}, and optionally \code{cov_full}
(3D array of covariances) when \code{compute_posterior = TRUE};
otherwise \code{NULL}.}
}
}
\description{
APCH.R
Fit the Adaptive Partial Conjunction Hypotheses (APCH) model. APCH uses a
two-layer hierarchical structure for multi-feature partial
conjunction analysis. The first layer ("feature layer") fits adaptive
shrinkage models to each feature to learn flexible mixtures of null and
non-null effects. The second layer ("configuration layer") aggregates these
feature-wise posteriors across all features using a block-diagonal
representation of the noise correlation and a configuration-layer solver
(default: a log-linear / Ising + ridge model; alternatives include MCMC/EM/mixsqp).

\code{apch_workhorse()} is a lower-level interface that exposes most modeling
and computing controls and by default computes the full posterior. Typical
users should call \code{apch()} instead.
}
\details{
The high-level interface \code{apch()} is intended for routine use with
minimal tuning. The lower-level interface \code{apch_workhorse()} exposes
additional controls (e.g. ashr grid parameters, null thresholds, solver
options) and by default computes the full posterior.

The analysis proceeds in stages:
\enumerate{
\item Fill and propagate names for rows (effects) and columns (features).
\item Fit adaptive shrinkage (via \pkg{ashr}) independently to each feature
to obtain mixture grids and weights (optionally with grid distillation).
\item Construct all possible feature activation configurations and run a
configuration-layer solver (C++ backend) to estimate configuration
probabilities (\code{config_res$w_mat}). The default solver is a
log-linear Ising model with ridge regularization; MCMC, EM and mixsqp
are also available.
\item Normalize and post-process the weights and perform level-by-level
partial conjunction inference to detect multi-feature signals.
\item Compute posterior summaries (means, variances, covariance) — done
automatically in \code{apch_workhorse()}, and partially exposed by
\code{apch()} via \code{post_mean_called}.
}

The function is intended for moderate-to-large scale datasets (e.g.
thousands to millions of effects × moderate number of features). It
leverages \pkg{future} for R-level parallelism and \pkg{RcppParallel} for
C++-level multi-threading.

In addition to the arguments of \code{apch()}, it allows:
\itemize{
\item Tuning the ashr null-bias prior (\code{lambda0_ash}).
\item Changing level-by-level thresholds (\code{null_th}, \code{ppa_min}).
\item Controlling grid distillation (\code{distill}).
\item Passing detailed ashr/grid options via \code{ashr_control}, which
are forwarded to \code{\link{fit_all_feature}}.
\item Choosing separate solvers \code{solver_stageA} and
\code{solver_stageB} for the configuration layer. By default,
Stage A uses \code{"mixsqp"} and Stage B uses \code{"loglinear"}
(Ising + ridge). Alternatives: \code{"mcmc"}, \code{"em"}, and a
softmax+\eqn{L2} \code{"loglinear"} solver at Stage A that
reparameterizes the pattern weights over \eqn{\eta}-configurations.
\item Controlling the convergence tolerance of the Stage-A
\code{"loglinear"} solver via \code{stageA_ll_tol} (separate from
the EM/mixsqp tolerance \code{tol_A} used by other Stage-A solvers).
\item Controlling the convergence tolerance of the Stage-B
\code{"loglinear"} solver via \code{stageB_ll_tol} (separate from
the EM/mixsqp tolerance \code{tol_B} used by other Stage-B solvers).
All other hyperparameters for Stage-B \code{"loglinear"} are chosen
internally in C++.
\item Setting \code{force_one_block = TRUE} in meta-analysis mode to force
a single global block at the configuration layer, with all features
distilled and configuration probabilities inferred from Stage A
only (Stage B is skipped). In \code{mode = "xwas"}, a single block
and Stage-A-only inference are always used.
\item Skipping the posterior layer by setting
\code{compute_posterior = FALSE}, which avoids calling
\code{\link{apch_posterior}} and can be useful for timing / debugging.
\item Directly tuning the fine ashr grid range
(\code{fine_s_min_mult}, \code{fine_s_max_mult}) and the
distillation step multipliers
(\code{fine_mult_distill}, \code{fine_mult_nodistill}), which are
passed to \code{\link{fit_all_feature}}.
}

Both \code{mode = "meta"} and \code{mode = "xwas"} are supported in the
feature, configuration and posterior layers, provided the corresponding
C++ backends (e.g. \code{block_stageA_xwas_cpp}) are available at compile time.
}
\seealso{
\code{\link{apch_workhorse}}, \code{\link{fit_all_feature}},
\code{\link{apch_posterior}}, \code{\link{level_by_level_inference}}
}
